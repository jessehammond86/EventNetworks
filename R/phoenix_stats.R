#'
#' Extract statistics from daily Phoenix event-networks.
#'
#'  Take a set of daily networks generated by the phoenix_net function,
#'  and extract a variety of daily statistics at the network and nodal
#'  levels.
#'
#'
#'  @param dailynets networkDynamic object containing daily event-nets
#'          produced via phoenix_net function.
#'
#'  @return phoenix_out a LIST object of tables containing descriptive
#'          statistics for daily event-networks.
#'
#'  @keywords phoenix, event data
#'
#'


phoenix_stats <- function(dailynets){

  ######
  #
  # Set up some initial values
  #
  ######

  codes <- names(dailynets)
  ndates <- length(dailynets[[1]])
  nodes <- network.vertex.names(dailynets[[1]])

  ######
  #
  # Set up some empty storage objects
  #
  ######

  # Storage for daily network outputs
  master_data <- vector('list', length(codes))
  names(master_data) <- as.character(codes)

  for(code in codes){

    ## Extract one set of daily event-networks
    event_dnet <- dailynets[[code]]
    ## Pull date information
    dates <- get.network.attribute(event_dnet, 'net.obs.period')$observations
    ## NOTE: this is a stupid way but I can't figure out how to natively
    ##  extract date-names from networkDynamic objects
    dates <- unique(as.integer(as.vector(unlist(dates)[1:(ndates*2)])))
    dates <- dates[!is.na(dates)]


    ######
    #
    # Set up some empty storage objects
    #
    ######

    # Table to store network-level stats
    event_network_stats <- data.table('date' = dates)

    # Table to store dyad-level stats
    event_dyad_stats <- data.table('date' = integer(), 'nodea' = integer()
                                   , 'nodeb' = integer())

    # Tables to store dyad-level stats
    event_indegreedist <- data.table('date' = dates)
    event_outdegreedist <- data.table('date' = dates)
    event_betweendist <- data.table('date' = dates)

    # Storage objects for irregular network-level data
    event_network_communities <- vector('list', length(dates))
    names(event_network_communities) <- as.character(dates)



    for(thisdate in dates){
      ## Pull one date's network
      daily_net <- network.collapse(event_dnet, at = thisdate)

      ## Convert to igraph object via 'intergraph' for additional metrics
      daily_graph <- asIgraph(daily_net)

      ######
      #
      # Extract a set of NETWORK-LEVEL statistics
      #
      ######

      ## Mean degree
      # Since it's a mean, in- vs out-degree doesn't matter
      net_degree <- mean(sna::degree(as.matrix.network(daily_net), gmode = 'digraph'))

      ## Density
      net_density <- network.density(daily_net)

      ## Transitivity
      net_trans <- gtrans(daily_net, diag =  F, mode = 'digraph')

      ## Dyad census
      net_dyads <- sna::dyad.census(as.matrix.network(daily_net))
      dimnames(net_dyads)[[2]] <- paste0('dyad', dimnames(net_dyads)[[2]])

      ## Triad census
      net_triads <- sna::triad.census(as.matrix.network(daily_net), mode = 'digraph')
      dimnames(net_triads)[[2]] <- paste0('triad', dimnames(net_triads)[[2]])

      ## Community detection
      ic <- infomap.community(daily_graph)

      ## Network community modularity
      ic_mod <- modularity(ic)

      ## Number and size of N>1 communities detected
      num_ic <- length(sizes(ic)[sizes(ic) > 1])
      size_ic <- sort(sizes(ic)[sizes(ic) > 1], decreasing = T)

      ## Mean community size of N>1 communities
      meansize_ic <- mean(size_ic)

      ## Share of total ties that connect different communities
      share_crossings <- sum(crossing(ic, daily_graph) == T) /
        length(crossing(ic, daily_graph))

      ######
      #
      # Extract a set of DYAD-LEVEL statistics
      #
      ######

      ## Dyad-level shared-community indicator
      # Get membership
      ic_membership <- membership(ic)
      # Convert to edgelist
      comm_ids <- (ic_membership[ic_membership %in% names(size_ic)])
      comm_members <- which(ic_membership %in% comm_ids)
      comm_edgelist <- cbind(comm_ids, comm_members)
      # Convert to bimodal adjacency matrix
      comm_membership <- matrix(0, length(unique(comm_ids)), 255)
      rownames(comm_membership) <- unique(comm_ids)
      colnames(comm_membership) <- 1:255
      comm_membership[comm_edgelist] <- 1
      # Matrix multiply to get shared membership matrix
      comm_adj <-  t(mat) %*% mat

      # Convert to daily edgelist
      comm_ties <- data.table(thisdate, which(comm_adj == 1, arr.ind = T))
      setnames(comm_ties, c('date', 'nodea', 'nodeb'))
      comm_ties <- comm_ties[nodea != nodeb]
      setkeyv(comm_ties, c('nodea', 'nodeb'))

      ######
      #
      # Extract a set of NODE-LEVEL statistics
      #
      ######

      ## Degree
      indegree_dist <- matrix(sna::degree(as.matrix.network(daily_net), cmode = 'indegree'
                                   , rescale = T), nrow = 1)
      dimnames(indegree_dist)[[2]] <- nodes

      # indegree_dist <- (indegree_dist - mean(indegree_dist)) / sd(indegree_dist)

      outdegree_dist <- matrix(sna::degree(as.matrix.network(daily_net), cmode = 'outdegree'
                                    , rescale = T), nrow = 1)
      dimnames(outdegree_dist)[[2]] <- nodes
      # outdegree_dist <- (outdegree_dist - mean(outdegree_dist)) / sd(outdegree_dist)

      ## Betweenness
      between_dist <- matrix(sna::betweenness(as.matrix.network(daily_net), gmode = 'digraph'
                                  , rescale = T), nrow = 1)
      dimnames(between_dist)[[2]] <- nodes


      ######
      #
      # Stuff all these stats into output objects
      #
      ######

      ## Network level statistics
      event_network_out[date %in% thisdate, mean_degree := net_degree]
      event_network_out[date %in% thisdate, density := net_density]
      event_network_out[date %in% thisdate, modularity := ic_mod]
      event_network_out[date %in% thisdate, num_communities := num_ic]
      event_network_out[date %in% thisdate, mean_commsize := meansize_ic]
      event_network_out[date %in% thisdate, cross_tieshare := share_crossings]
      event_network_out[date %in% thisdate, dimnames(net_dyads)[[2]] := data.table(net_dyads)]
      event_network_out[date %in% thisdate, dimnames(net_triads)[[2]] := data.table(net_triads)]

      ## Dyad level statistics
      event_dyad_stats <- rbind(event_dyad_stats, comm_ties)

      ## Node level statistics
      event_indegreedist[date %in% thisdate, dimnames(indegree_dist)[[2]] := data.table(indegree_dist)]
      event_outdegreedist[date %in% thisdate, dimnames(outdegree_dist)[[2]] := data.table(outdegree_dist)]
      event_betweendist[date %in% thisdate, dimnames(between_dist)[[2]] := data.table(between_dist)]

      ## Combine into list object for export
      event_data <- list(event_network_out, event_dyad_stats, event_indegreedist,
                         event_outdegreedist, event_betweendist)
      names(event_data) <- c('netstats', 'dyadstats', 'indeg', 'outdeg', 'between')
    }

    master_data[[code]] <- event_data


  }

}
